import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ophth_board/core/views/widgets/async_loading_button.dart';
import 'package:ophth_board/features/content_entries/model/announcement.dart'; // Assuming this model exists
import 'package:ophth_board/features/content_entries/model/content_entry.dart';

import '../../../../core/models/result.dart';
import '../../providers/announcements_provider.dart';

class AnnouncementForm extends ConsumerStatefulWidget {
  final Announcement? announcement; // For editing existing announcement

  const AnnouncementForm({super.key, this.announcement});

  @override
  ConsumerState<AnnouncementForm> createState() => _AnnouncementFormState();
}

class _AnnouncementFormState extends ConsumerState<AnnouncementForm> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _contentController = TextEditingController();
  final _authorController = TextEditingController();
  final _tagsController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _initializeForm();
  }

  void _initializeForm() {
    if (widget.announcement != null) {
      _titleController.text = widget.announcement!.title;
      _contentController.text = widget.announcement!.content;
      _authorController.text = widget.announcement!.author;
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    _contentController.dispose();
    _authorController.dispose();
    _tagsController.dispose();
    super.dispose();
  }

  Future<void> _submitForm() async {
    if (!_formKey.currentState!.validate()) return;

    try {
      final announcementNotifier = ref.read(announcementProvider.notifier);

      final announcement = Announcement(
        id:
            widget.announcement?.id ??
            '', // ID will be generated by backend/provider if new
        title: _titleController.text.trim(),
        content: _contentController.text.trim(),
        author: _authorController.text.trim(),
        createdAt: widget.announcement?.createdAt ?? DateTime.now(),
        updatedAt: DateTime.now(),
        status: ContentStatus
            .published, // Announcements are typically published directly
      );

      Result<void> result;

      if (widget.announcement != null) {
        result = await announcementNotifier.updateAnnouncement(announcement);
        if (result.isSuccess) {
          _showSuccessMessage('Announcement updated successfully!');
          Navigator.of(context).pop();
        } else {
          _showErrorMessage(
            result.errorMessage ?? 'Failed to update announcement',
          );
        }
      } else {
        result = await announcementNotifier.addAnnouncement(announcement);
        if (result.isSuccess) {
          _showSuccessMessage('Announcement created successfully!');
          Navigator.of(context).pop();
        } else {
          _showErrorMessage(
            result.errorMessage ?? 'Failed to create announcement',
          );
        }
      }
    } catch (e) {
      _showErrorMessage('Error submitting form: $e');
    }
  }

  void _showSuccessMessage(String message) {
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(SnackBar(content: Text(message)));
  }

  void _showErrorMessage(String message) {
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(SnackBar(content: Text(message)));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          widget.announcement != null
              ? 'Edit Announcement'
              : 'Create Announcement',
        ),
        elevation: 0,
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildTitleField(),
              const SizedBox(height: 16),
              _buildContentField(),
              const SizedBox(height: 16),
              _buildTagsField(),
              const SizedBox(height: 32),
              _buildSubmitButton(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTitleField() {
    return TextFormField(
      controller: _titleController,
      decoration: const InputDecoration(
        labelText: 'Title',
        hintText: 'Enter announcement title',
        border: OutlineInputBorder(),
        prefixIcon: Icon(Icons.title),
      ),
      validator: (value) {
        if (value == null || value.trim().isEmpty) {
          return 'Title is required';
        }
        if (value.trim().length < 3) {
          return 'Title must be at least 3 characters';
        }
        return null;
      },
      textInputAction: TextInputAction.next,
    );
  }

  Widget _buildAuthorField() {
    return TextFormField(
      controller: _authorController,
      decoration: const InputDecoration(
        labelText: 'Author',
        hintText: 'Enter author name (e.g., Admin)',
        border: OutlineInputBorder(),
        prefixIcon: Icon(Icons.person),
      ),
      validator: (value) {
        if (value == null || value.trim().isEmpty) {
          return 'Author is required';
        }
        return null;
      },
      textInputAction: TextInputAction.next,
    );
  }

  Widget _buildContentField() {
    return TextFormField(
      controller: _contentController,
      decoration: const InputDecoration(
        labelText: 'Content',
        hintText: 'Enter announcement content',
        border: OutlineInputBorder(),
        prefixIcon: Icon(Icons.description),
        alignLabelWithHint: true,
      ),
      maxLines: 6,
      validator: (value) {
        if (value == null || value.trim().isEmpty) {
          return 'Content is required';
        }
        if (value.trim().length < 10) {
          return 'Content must be at least 10 characters';
        }
        return null;
      },
      textInputAction: TextInputAction.newline,
    );
  }

  Widget _buildTagsField() {
    return TextFormField(
      controller: _tagsController,
      decoration: const InputDecoration(
        labelText: 'Tags (Optional)',
        hintText: 'Enter tags separated by commas (e.g., important, event)',
        border: OutlineInputBorder(),
        prefixIcon: Icon(Icons.tag),
        helperText: 'Separate multiple tags with commas',
      ),
      textInputAction: TextInputAction.done,
    );
  }

  Widget _buildSubmitButton() {
    return AsyncGenericButton(
      text: widget.announcement != null
          ? 'Update Announcement'
          : 'Create Announcement',
      onPressed: _submitForm,
      onError: (error) {
        _showErrorMessage('Error: $error');
      },
    );
  }
}
